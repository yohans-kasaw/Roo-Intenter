#!/usr/bin/env tsx
/**
 * Build script to generate built-in-skills.ts from SKILL.md files.
 *
 * This script scans the built-in/ directory for skill folders, parses each
 * SKILL.md file using gray-matter, validates the frontmatter, and generates
 * the built-in-skills.ts file.
 *
 * Run with: npx tsx src/services/skills/generate-built-in-skills.ts
 */

import * as fs from "fs/promises"
import * as path from "path"
import { execSync } from "child_process"
import matter from "gray-matter"

const BUILT_IN_DIR = path.join(__dirname, "built-in")
const OUTPUT_FILE = path.join(__dirname, "built-in-skills.ts")

interface SkillData {
	name: string
	description: string
	instructions: string
}

interface ValidationError {
	skillDir: string
	errors: string[]
}

/**
 * Validate a skill name according to Agent Skills spec:
 * - 1-64 characters
 * - lowercase letters, numbers, and hyphens only
 * - must not start/end with hyphen
 * - must not contain consecutive hyphens
 */
function validateSkillName(name: string): string[] {
	const errors: string[] = []

	if (name.length < 1 || name.length > 64) {
		errors.push(`Name must be 1-64 characters (got ${name.length})`)
	}

	const nameFormat = /^[a-z0-9]+(?:-[a-z0-9]+)*$/
	if (!nameFormat.test(name)) {
		errors.push(
			"Name must be lowercase letters/numbers/hyphens only (no leading/trailing hyphen, no consecutive hyphens)",
		)
	}

	return errors
}

/**
 * Validate a skill description:
 * - 1-1024 characters (after trimming)
 */
function validateDescription(description: string): string[] {
	const errors: string[] = []
	const trimmed = description.trim()

	if (trimmed.length < 1 || trimmed.length > 1024) {
		errors.push(`Description must be 1-1024 characters (got ${trimmed.length})`)
	}

	return errors
}

/**
 * Parse and validate a single SKILL.md file
 */
async function parseSkillFile(
	skillDir: string,
	dirName: string,
): Promise<{ skill?: SkillData; errors?: ValidationError }> {
	const skillMdPath = path.join(skillDir, "SKILL.md")

	try {
		const fileContent = await fs.readFile(skillMdPath, "utf-8")
		const { data: frontmatter, content: body } = matter(fileContent)

		const errors: string[] = []

		// Validate required fields
		if (!frontmatter.name || typeof frontmatter.name !== "string") {
			errors.push("Missing required 'name' field in frontmatter")
		}
		if (!frontmatter.description || typeof frontmatter.description !== "string") {
			errors.push("Missing required 'description' field in frontmatter")
		}

		if (errors.length > 0) {
			return { errors: { skillDir, errors } }
		}

		// Validate name matches directory name
		if (frontmatter.name !== dirName) {
			errors.push(`Frontmatter name "${frontmatter.name}" doesn't match directory name "${dirName}"`)
		}

		// Validate name format
		errors.push(...validateSkillName(dirName))

		// Validate description
		errors.push(...validateDescription(frontmatter.description))

		if (errors.length > 0) {
			return { errors: { skillDir, errors } }
		}

		return {
			skill: {
				name: frontmatter.name,
				description: frontmatter.description.trim(),
				instructions: body.trim(),
			},
		}
	} catch (error) {
		return {
			errors: {
				skillDir,
				errors: [`Failed to read or parse SKILL.md: ${error instanceof Error ? error.message : String(error)}`],
			},
		}
	}
}

/**
 * Escape a string for use in TypeScript template literal
 */
function escapeForTemplateLiteral(str: string): string {
	return str.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$\{/g, "\\${")
}

/**
 * Generate the TypeScript code for built-in-skills.ts
 */
function generateTypeScript(skills: Record<string, SkillData>): string {
	const skillEntries = Object.entries(skills)
		.map(([key, skill]) => {
			const escapedInstructions = escapeForTemplateLiteral(skill.instructions)
			return `\t"${key}": {
		name: "${skill.name}",
		description: "${skill.description.replace(/"/g, '\\"')}",
		instructions: \`${escapedInstructions}\`,
	}`
		})
		.join(",\n")

	return `/**
	* AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
	*
	* This file is generated by generate-built-in-skills.ts from the SKILL.md files
	* in the built-in/ directory. To modify built-in skills, edit the corresponding
	* SKILL.md file and run: pnpm generate:skills
	*
	* Generated at: ${new Date().toISOString()}
	*/

import { SkillMetadata, SkillContent } from "../../shared/skills"

interface BuiltInSkillDefinition {
	name: string
	description: string
	instructions: string
}

const BUILT_IN_SKILLS: Record<string, BuiltInSkillDefinition> = {
${skillEntries}
}

/**
 * Get all built-in skills as SkillMetadata objects
 */
export function getBuiltInSkills(): SkillMetadata[] {
	return Object.values(BUILT_IN_SKILLS).map((skill) => ({
		name: skill.name,
		description: skill.description,
		path: "built-in",
		source: "built-in" as const,
	}))
}

/**
 * Get a specific built-in skill's full content by name
 */
export function getBuiltInSkillContent(name: string): SkillContent | null {
	const skill = BUILT_IN_SKILLS[name]
	if (!skill) return null

	return {
		name: skill.name,
		description: skill.description,
		path: "built-in",
		source: "built-in" as const,
		instructions: skill.instructions,
	}
}

/**
 * Check if a skill name is a built-in skill
 */
export function isBuiltInSkill(name: string): boolean {
	return name in BUILT_IN_SKILLS
}

/**
 * Get names of all built-in skills
 */
export function getBuiltInSkillNames(): string[] {
	return Object.keys(BUILT_IN_SKILLS)
}
`
}

async function main() {
	console.log("Generating built-in skills from SKILL.md files...")

	// Check if built-in directory exists
	try {
		await fs.access(BUILT_IN_DIR)
	} catch {
		console.error(`Error: Built-in skills directory not found: ${BUILT_IN_DIR}`)
		process.exit(1)
	}

	// Scan for skill directories
	const entries = await fs.readdir(BUILT_IN_DIR)
	const skills: Record<string, SkillData> = {}
	const validationErrors: ValidationError[] = []

	for (const entry of entries) {
		const skillDir = path.join(BUILT_IN_DIR, entry)
		const stats = await fs.stat(skillDir)

		if (!stats.isDirectory()) {
			continue
		}

		// Check if SKILL.md exists
		const skillMdPath = path.join(skillDir, "SKILL.md")
		try {
			await fs.access(skillMdPath)
		} catch {
			console.warn(`Warning: No SKILL.md found in ${entry}, skipping`)
			continue
		}

		const result = await parseSkillFile(skillDir, entry)

		if (result.errors) {
			validationErrors.push(result.errors)
		} else if (result.skill) {
			skills[entry] = result.skill
			console.log(`  ✓ Parsed ${entry}`)
		}
	}

	// Report validation errors
	if (validationErrors.length > 0) {
		console.error("\nValidation errors:")
		for (const { skillDir, errors } of validationErrors) {
			console.error(`\n  ${path.basename(skillDir)}:`)
			for (const error of errors) {
				console.error(`    - ${error}`)
			}
		}
		process.exit(1)
	}

	// Check if any skills were found
	if (Object.keys(skills).length === 0) {
		console.error("Error: No valid skills found in built-in directory")
		process.exit(1)
	}

	// Generate TypeScript
	const output = generateTypeScript(skills)

	// Write output file
	await fs.writeFile(OUTPUT_FILE, output, "utf-8")

	// Format with prettier to ensure stable output
	// Run from workspace root (3 levels up from src/services/skills/) to find .prettierrc.json
	const workspaceRoot = path.resolve(__dirname, "..", "..", "..")
	try {
		execSync(`npx prettier --write "${OUTPUT_FILE}"`, {
			cwd: workspaceRoot,
			stdio: "pipe",
		})
		console.log(`\n✓ Generated and formatted ${OUTPUT_FILE}`)
	} catch {
		console.log(`\n✓ Generated ${OUTPUT_FILE} (prettier not available)`)
	}
	console.log(`  Skills: ${Object.keys(skills).join(", ")}`)
}

main().catch((error) => {
	console.error("Fatal error:", error)
	process.exit(1)
})
